// CodePen
https://codepen.io/Aleksi_Magner/pen/RmZjvy

// HTML
<div class="flip-countdown"></div>




// Sass
// == Config ==
$theme: 'light' // light or dark

$digitSize: 4.1em
$border_radius: .25em
$intervals_space_between: .15em

$digit_color: #4c6377
@if $theme == 'dark'
	$digit_color: #ccc

$bg_color: lighten($digit_color, 50%)
@if $theme == 'dark'
	$bg_color: #333

$description_color: lighten($digit_color, 18%)
@if $theme == 'dark'
	$description_color: darken($digit_color, 28%)
// == Config END ==

body
	@if $theme == light
		background-color: #ddd
	@if $theme == dark
		background-color: #fafafa

@keyframes last_rotate
	0%
		transform: rotateX(0deg)
		z-index: 1
	100%
		transform: rotateX(-180deg)
		z-index: 0
	
@keyframes new_rotate
	0%
		transform: rotateX(0deg)
		z-index: 0
	100%
		transform: rotateX(-180deg)
		z-index: 1

.flip-countdown
	display: flex
	justify-content: center
	font-family: 'Roboto', sans-serif
	font-size: $digitSize
	user-select: none
	overflow: hidden
	
.interval_cont
	display: flex
	justify-content: space-around
	width: auto
	overflow: hidden
			
	&:nth-child(n+1):not(:last-child)
		margin-right: $intervals_space_between
	
.description
	display: flex
	justify-content: center
	align-items: center
	margin-top: .5em
	margin-right: $intervals_space_between + .4em
	font-size: .29em
	font-weight: bold
	text-transform: uppercase
	color: $description_color
	text-shadow: .05em .05em .1em rgba(invert($description_color), .3)
	overflow: hidden

.digit_cont
	position: relative
	width: 1.2em
	height: 1.5em
	font-weight: 900
	line-height: 1.5em
	border-radius: $border_radius
	color: $digit_color
	border-bottom: .01em solid rgba($digit_color, .1)
	box-shadow: 0 .2em .3em -.1em rgba($digit_color, .1)
	perspective: 1.5em * 2
	box-sizing: border-box
	overflow: hidden

	&:after
		content: ''
		position: absolute
		top: 50%
		width: 100%
		height: .015em
		@if $theme == light
			background: rgba(lighten($digit_color, 25%), .25)
		@if $theme == dark
			background: rgba(darken($digit_color, 55%), .25)
		box-shadow: 0 .01em .02em 0 rgba(255, 255, 255, .1)
		z-index: 1
	
	&:nth-child(n+1):not(:last-child)
		margin-right: .05em
	
	span
		display: flex
		justify-content: center
		align-items: center
		position: absolute
		bottom: 50%
		width: 100%
		height: 100%
		overflow: hidden
		
	.last_placeholder,
	.new_placeholder,
	.last_rotate,
	.new_rotate
		position: absolute
		left: 0
		width: 100%
		height: 50%
		text-align: center
		overflow: hidden
		box-sizing: border-box
	
	.last_placeholder
		bottom: 0
		border-radius: 0 0 $border_radius $border_radius
		@if $theme == 'light'
			background: linear-gradient(to bottom, $bg_color -90%, #fff 100%), $bg_color
		@if $theme == 'dark'
			background: $bg_color
			
	.new_placeholder
		box-shadow: inset 0 .01em 0 0 rgba(#fff, .5)
	
	.new_placeholder,
	.last_rotate,
	.new_rotate
		top: 0
		border-radius: $border_radius $border_radius 0 0
		@if $theme == 'light'
			background: linear-gradient(to bottom, $bg_color 10%, #fff 200%), $bg_color
		@if $theme == 'dark'
			background: $bg_color
	
	.last_rotate
		transform-origin: 100% 100%
		animation: last_rotate .5s linear forwards

	.new_rotate
		border-top: .01em solid rgba($digit_color, .3)
		@if $theme == 'light'
			background: linear-gradient(to top, $bg_color -90%, #fff 100%), $bg_color
		@if $theme == 'dark'
			background: $bg_color
		transform-origin: 100% 100%
		animation: new_rotate .5s linear forwards
	
		.rotated
			width: 100%
			height: 100%
			border-radius: 0 0 $border_radius $border_radius
			transform: rotateX(180deg)
			overflow: hidden





// JS
// == Settings ==
const lang = 'EN'; // RU or EN description
const typeCountdown = 'time'; // 'time' to set the countdown to a specific time or 'date' to set the countdown to the designated date

let EndDate = '2019/12/31, 23:00'; // Expiration Date yyyy/mm/dd, hh:mm. Working only if typeCountdown = 'date'

let days = 1; // Number of days before the end. Working only if typeCountdown = 'time'
let timeOut = '00:00'; // 'hh:mm'. Number of hours and minutes before the end. Working only if typeCountdown = 'time'

const ColorDigitEnd = '#bfbfbf';
// == Settings END ==

let hours, minutes, target_date, ExpirationDate;
let formatCountdown = null;
let day_lang = hour_lang = minute_lang = second_lang = '';


function daysLeft(target) {
	if (target > (24 * 60 * 60 * 1000)) { formatCountdown = 'day|hour|minute|second'; }
	else if (target > (60 * 60 * 1000)) { formatCountdown = 'hour|minute|second'; }
	else { formatCountdown = 'minute|second'; }
}

if (typeCountdown === 'time') {
	timeOut = timeOut.split(':');
	hours = timeOut[0];
	minutes = timeOut[1];
	target_date = ((days * 24 * 60 * 60 + hours * 60 * 60 + minutes * 60) * 1000);
	
	daysLeft(target_date);
	target_date += new Date().getTime();
} else if (typeCountdown === 'date') {
	ExpirationDate = new Date(EndDate);
	target_date = (ExpirationDate - new Date());
	daysLeft(target_date);
	target_date += new Date().getTime();
}
else {
	target_date = 0;
	formatCountdown = 'day|hour|minute|second';
}

if (lang === 'RU') {
	day_lang = 'Дней';
	hour_lang = 'Часов';
	minute_lang = 'Минут';
	second_lang = 'Секунд';
} else if (lang === 'EN') {
	day_lang = 'Days';
	hour_lang = 'Hours';
	minute_lang = 'Minutes';
	second_lang = 'Seconds';
}
	
class Countdown {
	get TIMESTAMP_SECOND() { return 1000; }
	get TIMESTAMP_MINUTE() { return 60 * this.TIMESTAMP_SECOND; }
	get TIMESTAMP_HOUR() { return 60 * this.TIMESTAMP_MINUTE; }
	get TIMESTAMP_DAY() { return 24 * this.TIMESTAMP_HOUR; }

	constructor(userOptions) {
		this.options = {
			cont: null,
			countdown: true,
			endDate: {
				day: 0,
				hour: 0,
				minute: 0,
				second: 0 },
			endCallback: null,
			outputFormat: formatCountdown,
			outputTranslation: {
				day: day_lang,
				hour: hour_lang,
				minute: minute_lang,
				second: second_lang }
		};

    this.lastTick = null;
    this.intervalsBySize = ['day', 'hour', 'minute', 'second'];
    this.interval = null;
    this.digitConts = {};
    this._assignOptions(this.options, userOptions);
	}

  start() {
		let endDate, endDateData;
    this._fixCompatibility();

    endDate = this._getDate(this.options.endDate);
    endDateData = this._prepareTimeByOutputFormat(endDate);

    this._writeData(endDateData);
    this.lastTick = endDateData;

    if (this.options.countdown && endDate.getTime() <= Date.now()) {
			if (typeof this.options.endCallback === 'function') {
				this.stop();
				this.options.endCallback();
			}
		} else {
			this.interval = setInterval(() =>
				{ this._updateView(this._prepareTimeByOutputFormat(endDate)); },
				this.TIMESTAMP_SECOND);
		}
	}
	
	stop() { if (this.interval !== null) { clearInterval(this.interval); }}

	_getDate(date) {
		if (typeof date === 'object') {
			if (date instanceof Date) { return date; }
			else {
				let expectedValues = {
					day: 0,
					hour: 0,
					minute: 0,
					second: 0
				};
				
				for (let i in expectedValues) {
					if (expectedValues.hasOwnProperty(i) && date.hasOwnProperty(i)) { expectedValues[i] = date[i]; }
				}
				return new Date(expectedValues.day, expectedValues.hour, expectedValues.minute, expectedValues.second);
			}
		} else if (typeof date === 'number' || typeof date === 'string') { return new Date(date); }
		else { return new Date(); }
	}

	_prepareTimeByOutputFormat(dateObj) {
		let usedIntervals, output = {}, timeDiff;
		
		usedIntervals = this.intervalsBySize.filter(item => { return this.options.outputFormat.split('|').indexOf(item) !== -1; });
		
		timeDiff = this.options.countdown ? dateObj.getTime() - Date.now() : Date.now() - dateObj.getTime();
		
		usedIntervals.forEach(item => {
			let value;
			if (timeDiff > 0) {
				switch (item) {
					case 'day':
						value = Math.trunc(timeDiff / this.TIMESTAMP_DAY);
						timeDiff -= value * this.TIMESTAMP_DAY;
						break;
					case 'hour':
						value = Math.trunc(timeDiff / this.TIMESTAMP_HOUR);
						timeDiff -= value * this.TIMESTAMP_HOUR;
						break;
					case 'minute':
						value = Math.trunc(timeDiff / this.TIMESTAMP_MINUTE);
						timeDiff -= value * this.TIMESTAMP_MINUTE;
						break;
					case 'second':
						value = Math.trunc(timeDiff / this.TIMESTAMP_SECOND);
						timeDiff -= value * this.TIMESTAMP_SECOND;
						break;
				}
			} else {
				value = '00';
				const elements = document.querySelectorAll('.digit_cont');
				for (let i = 0; i < elements.length; i++) { elements[i].style.color = ColorDigitEnd; }
			}
			output[item] = (('' + value).length < 2 ? '0' + value : '' + value).split('');
		});
    return output;
  }
	
	_fixCompatibility() {
		Math.trunc = Math.trunc || function (x) {
			if (isNaN(x)) { return NaN; }
			if (x > 0) { return Math.floor(x); }
			return Math.ceil(x);
		};
	}

	_writeData(data) {
		let code = ``, intervalName;
		
		for (intervalName in data) {
			if (data.hasOwnProperty(intervalName)) {
				let element = `<div><div class="interval_cont interval_cont_${intervalName}">`,
        intervalDescription = `<div class="description"> ${this.options.outputTranslation[intervalName]}</div>`;
        
				data[intervalName].forEach((digit, index) => { element += `<div class="digit_cont digit_cont_${index}" id="test">${this._getDigitElementString(digit, 0)}</div>`; });
				
				code += element + '</div>' + intervalDescription + '</div>';
			}
		}
		this.options.cont.innerHTML = code;
		this.lastTick = data;
	}

	_getDigitElementString(newDigit, lastDigit) {
		return `<div class="last_placeholder"><span>${lastDigit}</span></div>
						<div class="new_placeholder">${newDigit}</div>
						<div class="last_rotate">${lastDigit}</div>
						<div class="new_rotate">
							<div class="rotated"><span>${newDigit}</span></div>
						</div>`;
	}

	_updateView(data) {
		for (let intervalName in data) {
			if (data.hasOwnProperty(intervalName)) {
				data[intervalName].forEach((digit, index) => {
						if (this.lastTick !== null
								&& this.lastTick[intervalName][index]
								!== data[intervalName][index])
						{
							this._getDigitCont(intervalName, index).innerHTML = this._getDigitElementString(data[intervalName][index], this.lastTick[intervalName][index]);
						}
				});
			}
		}
		this.lastTick = data;
	}

	_getDigitCont(intervalName, index) {
		if (!this.digitConts[`${intervalName}_${index}`]) {
			this.digitConts[`${intervalName}_${index}`] = this.options.cont.querySelector(`.interval_cont_${intervalName} .digit_cont_${index}`);
		}
		return this.digitConts[`${intervalName}_${index}`];
	}

	_assignOptions(options, userOptions) {
		for (let i in options) {
			if (options.hasOwnProperty(i) && userOptions.hasOwnProperty(i)) {
				if (options[i] !== null && typeof options[i] === 'object' && typeof userOptions[i] === 'object') {
					this._assignOptions(options[i], userOptions[i]);
				}
				else { options[i] = userOptions[i]; }
			}
		}
	}
}

let cd = new Countdown({
  cont: document.querySelector('.flip-countdown'),
  endDate: target_date,
  outputTranslation: {
		day: day_lang,
		hour: hour_lang,
		minute: minute_lang,
		second: second_lang },
  endCallback: null,
  outputFormat: formatCountdown
});
cd.start();
